import tap from 'tap';
import { strictEqual } from 'node:assert';
// import fs from 'fs/promises';
import { Config } from './Config.js';

const originalArgv = process.argv;

tap.test('sets default values on Config instance', async () => {
  process.argv = ['node', '/dist/bin/index.js', './website.html'];

  const config = await new Config().init();

  strictEqual(config.isDebug, false, 'isDebug should be false');
  strictEqual(config.displayAllMessages, false, 'displayAllMessages should be false');
  strictEqual(config.outputPath, undefined, 'outputPath should be undefined');
});

tap.test('should parse basic options and init config instance with them', async () => {
  process.argv = ['node', '/dist/bin/index.js', '-d', '--all', '-o', './output.json', './website.html'];

  const config = await new Config().init();

  strictEqual(config.isDebug, true, 'isDebug should be true');
  strictEqual(config.displayAllMessages, true, 'displayAllMessages should be true');
  strictEqual(config.outputPath, './output.json', 'outputPath should be equal to ./output.json');
});

tap.test('should log error if readFile throws error but not related to accessed file', async t => {
  process.argv = ['node', '/dist/bin/index.js', './website.html'];

  const consoleErrorCapture = t.capture(console, 'error', () => {});

  const { Config } = (await t.mockImport('./Config.js', {
    'node:fs/promises': {
      readFile: async () => {
        throw new Error('Error without code');
      },
    },
  })) as typeof import('./Config.js');

  await new Config().init();

  strictEqual(consoleErrorCapture.calls.length, 1);
  strictEqual(consoleErrorCapture.calls[0].args[0], 'Error without code');
});

tap.after(() => {
  process.argv = originalArgv;
});

// describe('Config', () => {
//   const originalArgv = process.argv;

//   it('should set default values on Config instance', async () => {

//   });

//   it('should parse basic options and init config instance with them', async () => {
//     process.argv = ['node', '/dist/bin/index.js', '-d', '--all', '-o', './output.json', './website.html'];

//     const config = await new Config().init();

//     strictEqual(config.isDebug, true, 'isDebug should be true');
//     strictEqual(config.displayAllMessages, true, 'displayAllMessages should be true');
//     strictEqual(config.outputPath, './output.json', 'outputPath should be equal to ./output.json');
//   });

//   it('', async () => {
//     process.argv = ['node', '/dist/bin/index.js', './website.html'];

//     const readFileMock = mock.method(fs, 'readFile', async () => {
//       throw new Error('Error without code');
//     });
//     const consoleErrorMock = mock.method(console, 'error', () => {});

//     await new Config().init();
//     console.log(readFileMock.mock.callCount());
//     strictEqual(consoleErrorMock.mock.callCount(), 1, 'console.error should be called once');
//     strictEqual(
//       consoleErrorMock.mock.calls[0].arguments,
//       'Unknow error during reading/parsing config file',
//       'console.error should be with specific error',
//     );
//   });

//   after(() => {
//     process.argv = originalArgv;
//   });
// });
